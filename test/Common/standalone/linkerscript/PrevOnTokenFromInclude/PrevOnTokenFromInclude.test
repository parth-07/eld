#---PrevOnTokenFromInclude.test------------------- Executable,LS------------------#
#BEGIN_COMMENT
# This test verifies that the linker script parser moving to the previous token
# functionality works correctly when the previous token comes from an INCLUDE
# file.
#END_COMMENT
#START_TEST
RUN: %clang %clangopts -o %t1.1.o %p/Inputs/1.c -c -ffunction-sections
RUN: %link -MapStyle txt %linkopts -o %t1.s1.out -L %p/Inputs -T %p/Inputs/script1.t \
RUN:   -Map %t1.s1.map.txt 2>&1 | %filecheck %s
RUN: %filecheck %s --check-prefix S1MAP < %t1.s1.map.txt
RUN: %link -MapStyle txt %linkopts -o %t1.s2.out -L %p/Inputs -T %p/Inputs/script2.t \
RUN:   -Map %t1.s2.map.txt 2>&1 | %filecheck %s
RUN: %filecheck %s --check-prefix S2MAP < %t1.s2.map.txt
#END_TEST

CHECK: Note: Rule __function__ in output section .foo does not have any sections specified
CHECK-NOT: .RULE_MATCHING_BUG
CHECK-NOT: does not have any sections specified

S1MAP: .foo
S1MAP: *(.text.bar) #Rule 1
S1MAP: __function__(*) #Rule 2
S1MAP: .RULE_MATCHING_BUG
S1MAP: *(.text.foo)

S2MAP: .foo
S2MAP: *(.text.bar) #Rule 1
S2MAP: __function__(*) #Rule 2